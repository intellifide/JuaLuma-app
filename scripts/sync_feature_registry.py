#!/usr/bin/env python3
"""
Sync feature registry files from docs/feature_requirements.yaml.

Generates:
- frontend-app/src/shared/accessControl.ts
- backend/services/access_control/registry.py
"""

from __future__ import annotations

from pathlib import Path
from typing import Any

ROOT = Path(__file__).resolve().parents[1]
SOURCE_PATH = ROOT / "docs" / "feature_requirements.yaml"
TS_OUT = ROOT / "frontend-app" / "src" / "shared" / "accessControl.ts"
PY_OUT = ROOT / "backend" / "services" / "access_control" / "registry.py"

TIER_ORDER = ["free", "essential", "pro", "ultimate"]


def _parse_simple_yaml(text: str) -> dict[str, Any]:
    """
    Minimal YAML parser for the limited registry structure.
    Supports:
    - comments
    - top-level 'features:' map
    - 2-space indentation for feature keys
    - 4-space indentation for key/value pairs
    """
    data: dict[str, Any] = {}
    current_section: dict[str, Any] | None = None
    current_key: str | None = None

    for raw_line in text.splitlines():
        line = raw_line.rstrip()
        if not line or line.lstrip().startswith("#"):
            continue
        indent = len(line) - len(line.lstrip())
        stripped = line.strip()

        if indent == 0:
            key = stripped.rstrip(":")
            if key == "features":
                current_section = {}
                data["features"] = current_section
            continue

        if indent == 2 and current_section is not None:
            current_key = stripped.rstrip(":")
            current_section[current_key] = {}
            continue

        if indent == 4 and current_section is not None and current_key is not None:
            key, _, value = stripped.partition(":")
            value = value.strip()
            if value == "":
                parsed: Any = ""
            elif value.lower() == "true":
                parsed = True
            elif value.lower() == "false":
                parsed = False
            else:
                try:
                    parsed = int(value)
                except ValueError:
                    parsed = value.strip('"').strip("'")
            current_section[current_key][key.strip()] = parsed

    return data


def _load_yaml(path: Path) -> dict[str, Any]:
    text = path.read_text()
    try:
        import yaml  # type: ignore

        return yaml.safe_load(text) or {}
    except Exception:
        return _parse_simple_yaml(text)


def _build_registry(features: dict[str, Any]):
    feature_entries: list[dict[str, Any]] = []
    account_limits: dict[str, dict[str, int]] = {}

    for feature_key in sorted(features.keys()):
        spec = features.get(feature_key) or {}
        if not isinstance(spec, dict):
            continue

        if any(k in spec for k in ("tier", "preview_enabled", "description")):
            tier = str(spec.get("tier", "free")).lower()
            preview = bool(spec.get("preview_enabled", False))
            description = str(spec.get("description", "")).strip()
            feature_entries.append(
                {
                    "key": feature_key,
                    "tier": tier,
                    "preview_enabled": preview,
                    "description": description,
                }
            )

        limit_keys = [k for k in spec.keys() if k.endswith("_limit")]
        if limit_keys:
            account_type = (
                feature_key.split(".", 1)[1]
                if feature_key.startswith("accounts.")
                else feature_key
            )
            limits: dict[str, int] = {}
            for tier in TIER_ORDER:
                key = f"{tier}_limit"
                if key in spec:
                    limits[tier] = int(spec[key])
            if limits:
                account_limits[account_type] = limits

    account_limits_by_tier: dict[str, dict[str, int]] = {tier: {} for tier in TIER_ORDER}
    for account_type, limits in account_limits.items():
        for tier, limit in limits.items():
            account_limits_by_tier[tier][account_type] = int(limit)

    return feature_entries, account_limits, account_limits_by_tier


def _format_ts(feature_entries, account_limits, account_limits_by_tier) -> str:
    feature_keys = [entry["key"] for entry in feature_entries]
    account_types = sorted(account_limits.keys())

    lines: list[str] = []
    lines.append("/* AUTO-GENERATED FILE. DO NOT EDIT.")
    lines.append(" * Generated by scripts/sync_feature_registry.py")
    lines.append(" */")
    lines.append("")
    lines.append("export const featureKeys = [")
    for key in feature_keys:
        lines.append(f"  {key!r},")
    lines.append("] as const")
    lines.append("export type FeatureKey = (typeof featureKeys)[number]")
    lines.append("")
    lines.append("export const accountTypes = [")
    for key in account_types:
        lines.append(f"  {key!r},")
    lines.append("] as const")
    lines.append("export type AccountType = (typeof accountTypes)[number]")
    lines.append("")
    lines.append("export type TierSlug = 'free' | 'essential' | 'pro' | 'ultimate'")
    lines.append("export enum Tier {")
    lines.append("  FREE = 0,")
    lines.append("  ESSENTIAL = 1,")
    lines.append("  PRO = 2,")
    lines.append("  ULTIMATE = 3,")
    lines.append("}")
    lines.append("")
    lines.append("export const tierOrder: Record<TierSlug, number> = {")
    lines.append("  free: 0,")
    lines.append("  essential: 1,")
    lines.append("  pro: 2,")
    lines.append("  ultimate: 3,")
    lines.append("}")
    lines.append("")
    lines.append(
        "export const featureRequirements: Record<FeatureKey, { tier: Tier; previewEnabled: boolean; description: string }> = {"
    )
    for entry in feature_entries:
        tier_enum = entry["tier"].upper()
        preview = "true" if entry["preview_enabled"] else "false"
        description = entry["description"].replace("\\", "\\\\").replace('"', '\\"')
        lines.append(f"  {entry['key']!r}: {{ tier: Tier.{tier_enum}, previewEnabled: {preview}, description: \"{description}\" }},")
    lines.append("}")
    lines.append("")
    lines.append(
        "export const accountLimits: Record<AccountType, Record<TierSlug, number>> = {"
    )
    for account_type in account_types:
        limits = account_limits[account_type]
        inner = ", ".join([f"{tier}: {limits.get(tier, 0)}" for tier in TIER_ORDER])
        lines.append(f"  {account_type!r}: {{ {inner} }},")
    lines.append("}")
    lines.append("")
    lines.append(
        "export const accountLimitsByTier: Record<TierSlug, Record<AccountType, number>> = {"
    )
    for tier in TIER_ORDER:
        tier_limits = account_limits_by_tier.get(tier, {})
        inner = ", ".join([f"{acct!r}: {tier_limits.get(acct, 0)}" for acct in account_types])
        lines.append(f"  {tier}: {{ {inner} }},")
    lines.append("}")
    lines.append("")
    lines.append("export const normalizeTierSlug = (value?: string | null): TierSlug | null => {")
    lines.append("  if (!value) return null")
    lines.append("  const normalized = value.toLowerCase()")
    lines.append("  if (normalized.includes('ultimate')) return 'ultimate'")
    lines.append("  if (normalized.includes('pro')) return 'pro'")
    lines.append("  if (normalized.includes('essential')) return 'essential'")
    lines.append("  if (normalized.includes('free')) return 'free'")
    lines.append("  return null")
    lines.append("}")
    lines.append("")
    lines.append("const tierEnumFromSlug = (tier: TierSlug): Tier => {")
    lines.append("  switch (tier) {")
    lines.append("    case 'ultimate':")
    lines.append("      return Tier.ULTIMATE")
    lines.append("    case 'pro':")
    lines.append("      return Tier.PRO")
    lines.append("    case 'essential':")
    lines.append("      return Tier.ESSENTIAL")
    lines.append("    default:")
    lines.append("      return Tier.FREE")
    lines.append("  }")
    lines.append("}")
    lines.append("")
    lines.append("export const tierSlugFromPlan = (value?: string | null): TierSlug => {")
    lines.append("  return normalizeTierSlug(value) ?? 'free'")
    lines.append("}")
    lines.append("")
    lines.append("export const tierFromPlan = (value?: string | null): Tier => {")
    lines.append("  return tierEnumFromSlug(tierSlugFromPlan(value))")
    lines.append("}")
    lines.append("")
    lines.append("const resolveTierEnum = (tier: Tier | TierSlug): Tier => {")
    lines.append("  return typeof tier === 'string' ? tierEnumFromSlug(tier) : tier")
    lines.append("}")
    lines.append("")
    lines.append("export const canUseFeature = (featureKey: FeatureKey, userTier: Tier | TierSlug): boolean => {")
    lines.append("  const requirement = featureRequirements[featureKey]")
    lines.append("  if (!requirement) return false")
    lines.append("  return resolveTierEnum(userTier) >= requirement.tier")
    lines.append("}")
    lines.append("")
    lines.append("export const canPreviewFeature = (featureKey: FeatureKey): boolean => {")
    lines.append("  return Boolean(featureRequirements[featureKey]?.previewEnabled)")
    lines.append("}")
    lines.append("")
    lines.append("export const isPremiumFeature = (featureKey: FeatureKey): boolean => {")
    lines.append("  return featureRequirements[featureKey]?.tier !== Tier.FREE")
    lines.append("}")
    lines.append("")
    return "\n".join(lines) + "\n"


def _format_py(feature_entries, account_limits, account_limits_by_tier) -> str:
    lines: list[str] = []
    lines.append("# AUTO-GENERATED FILE. DO NOT EDIT.")
    lines.append("# Generated by scripts/sync_feature_registry.py")
    lines.append("from __future__ import annotations")
    lines.append("")
    lines.append("from enum import IntEnum")
    lines.append("from typing import Any")
    lines.append("")
    lines.append("TIER_ORDER = ('free', 'essential', 'pro', 'ultimate')")
    lines.append("")
    lines.append("class Tier(IntEnum):")
    lines.append("    FREE = 0")
    lines.append("    ESSENTIAL = 1")
    lines.append("    PRO = 2")
    lines.append("    ULTIMATE = 3")
    lines.append("")
    lines.append("feature_requirements: dict[str, dict[str, Any]] = {")
    for entry in feature_entries:
        tier_enum = entry["tier"].upper()
        preview = "True" if entry["preview_enabled"] else "False"
        desc = repr(entry["description"])
        lines.append(f"    {entry['key']!r}: {{")
        lines.append(f"        'tier': Tier.{tier_enum},")
        lines.append(f"        'preview_enabled': {preview},")
        lines.append(f"        'description': {desc},")
        lines.append("    },")
    lines.append("}")
    lines.append("")
    lines.append("account_limits: dict[str, dict[str, int]] = {")
    for account_type in sorted(account_limits.keys()):
        limits = account_limits[account_type]
        inner = ", ".join([f"'{tier}': {limits.get(tier, 0)}" for tier in TIER_ORDER])
        lines.append(f"    {account_type!r}: {{{inner}}},")
    lines.append("}")
    lines.append("")
    lines.append("account_limits_by_tier: dict[str, dict[str, int]] = {")
    for tier in TIER_ORDER:
        tier_limits = account_limits_by_tier.get(tier, {})
        inner = ", ".join([f"'{acct}': {tier_limits.get(acct, 0)}" for acct in sorted(account_limits.keys())])
        lines.append(f"    '{tier}': {{{inner}}},")
    lines.append("}")
    lines.append("")
    lines.append("def tier_from_string(value: str | Tier | None) -> Tier:")
    lines.append("    if isinstance(value, Tier):")
    lines.append("        return value")
    lines.append("    if not value:")
    lines.append("        return Tier.FREE")
    lines.append("    normalized = value.lower()")
    lines.append("    if 'ultimate' in normalized:")
    lines.append("        return Tier.ULTIMATE")
    lines.append("    if 'pro' in normalized:")
    lines.append("        return Tier.PRO")
    lines.append("    if 'essential' in normalized:")
    lines.append("        return Tier.ESSENTIAL")
    lines.append("    return Tier.FREE")
    lines.append("")
    lines.append("def get_required_tier(feature_key: str) -> Tier | None:")
    lines.append("    entry = feature_requirements.get(feature_key)")
    lines.append("    if not entry:")
    lines.append("        return None")
    lines.append("    return entry.get('tier') if isinstance(entry.get('tier'), Tier) else None")
    lines.append("")
    lines.append("def can_use_feature(feature_key: str, user_tier: str | Tier | None) -> bool:")
    lines.append("    entry = feature_requirements.get(feature_key)")
    lines.append("    if not entry:")
    lines.append("        return False")
    lines.append("    required = entry.get('tier', Tier.FREE)")
    lines.append("    return tier_from_string(user_tier) >= required")
    lines.append("")
    lines.append("def can_preview_feature(feature_key: str) -> bool:")
    lines.append("    entry = feature_requirements.get(feature_key)")
    lines.append("    if not entry:")
    lines.append("        return False")
    lines.append("    return bool(entry.get('preview_enabled'))")
    lines.append("")
    lines.append("def get_feature_description(feature_key: str) -> str:")
    lines.append("    entry = feature_requirements.get(feature_key)")
    lines.append("    if not entry:")
    lines.append("        return ''")
    lines.append("    return str(entry.get('description') or '')")
    lines.append("")
    return "\n".join(lines) + "\n"


def main() -> None:
    data = _load_yaml(SOURCE_PATH)
    features = data.get("features") if isinstance(data, dict) else None
    if not isinstance(features, dict):
        raise SystemExit("Invalid registry format: missing 'features' map")

    feature_entries, account_limits, account_limits_by_tier = _build_registry(features)

    TS_OUT.parent.mkdir(parents=True, exist_ok=True)
    PY_OUT.parent.mkdir(parents=True, exist_ok=True)

    TS_OUT.write_text(_format_ts(feature_entries, account_limits, account_limits_by_tier))
    PY_OUT.write_text(_format_py(feature_entries, account_limits, account_limits_by_tier))

    print(f"Wrote {TS_OUT.relative_to(ROOT)}")
    print(f"Wrote {PY_OUT.relative_to(ROOT)}")


if __name__ == "__main__":
    main()
