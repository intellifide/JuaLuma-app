/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.intellifide.jualuma.sharedcore.api.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.intellifide.jualuma.sharedcore.api.models.AccountCreate
import com.intellifide.jualuma.sharedcore.api.models.AccountLimitsResponse
import com.intellifide.jualuma.sharedcore.api.models.AccountResponse
import com.intellifide.jualuma.sharedcore.api.models.AccountSyncResponse
import com.intellifide.jualuma.sharedcore.api.models.AccountUpdate
import com.intellifide.jualuma.sharedcore.api.models.CexLinkRequest
import com.intellifide.jualuma.sharedcore.api.models.HTTPValidationError
import com.intellifide.jualuma.sharedcore.api.models.Web3LinkRequest

import com.squareup.moshi.Json

import com.intellifide.jualuma.sharedcore.api.infrastructure.ApiClient
import com.intellifide.jualuma.sharedcore.api.infrastructure.ApiResponse
import com.intellifide.jualuma.sharedcore.api.infrastructure.ClientException
import com.intellifide.jualuma.sharedcore.api.infrastructure.ClientError
import com.intellifide.jualuma.sharedcore.api.infrastructure.ServerException
import com.intellifide.jualuma.sharedcore.api.infrastructure.ServerError
import com.intellifide.jualuma.sharedcore.api.infrastructure.MultiValueMap
import com.intellifide.jualuma.sharedcore.api.infrastructure.PartConfig
import com.intellifide.jualuma.sharedcore.api.infrastructure.RequestConfig
import com.intellifide.jualuma.sharedcore.api.infrastructure.RequestMethod
import com.intellifide.jualuma.sharedcore.api.infrastructure.ResponseType
import com.intellifide.jualuma.sharedcore.api.infrastructure.Success
import com.intellifide.jualuma.sharedcore.api.infrastructure.toMultiValue

open class AccountsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/accounts/manual
     * Create Manual Account
     * Create a manual account for offline balances or custom asset/liability tracking.
     * @param accountCreate 
     * @param authorization  (optional)
     * @return AccountResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createManualAccountApiAccountsManualPost(accountCreate: AccountCreate, authorization: kotlin.String? = null) : AccountResponse {
        val localVarResponse = createManualAccountApiAccountsManualPostWithHttpInfo(accountCreate = accountCreate, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/accounts/manual
     * Create Manual Account
     * Create a manual account for offline balances or custom asset/liability tracking.
     * @param accountCreate 
     * @param authorization  (optional)
     * @return ApiResponse<AccountResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createManualAccountApiAccountsManualPostWithHttpInfo(accountCreate: AccountCreate, authorization: kotlin.String?) : ApiResponse<AccountResponse?> {
        val localVariableConfig = createManualAccountApiAccountsManualPostRequestConfig(accountCreate = accountCreate, authorization = authorization)

        return request<AccountCreate, AccountResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createManualAccountApiAccountsManualPost
     *
     * @param accountCreate 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun createManualAccountApiAccountsManualPostRequestConfig(accountCreate: AccountCreate, authorization: kotlin.String?) : RequestConfig<AccountCreate> {
        val localVariableBody = accountCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/accounts/manual",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/accounts/{account_id}
     * Delete Account
     * Delete an account and cascade related data.
     * @param accountId 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAccountApiAccountsAccountIdDelete(accountId: java.util.UUID, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = deleteAccountApiAccountsAccountIdDeleteWithHttpInfo(accountId = accountId, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/accounts/{account_id}
     * Delete Account
     * Delete an account and cascade related data.
     * @param accountId 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAccountApiAccountsAccountIdDeleteWithHttpInfo(accountId: java.util.UUID, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = deleteAccountApiAccountsAccountIdDeleteRequestConfig(accountId = accountId, authorization = authorization)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteAccountApiAccountsAccountIdDelete
     *
     * @param accountId 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun deleteAccountApiAccountsAccountIdDeleteRequestConfig(accountId: java.util.UUID, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/accounts/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/accounts/{account_id}
     * Get Account Details
     * Get detailed information for a specific account.  - **account_id**: UUID of the account.  Returns account details including the 10 most recent transactions.
     * @param accountId 
     * @param authorization  (optional)
     * @return AccountResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountDetailsApiAccountsAccountIdGet(accountId: java.util.UUID, authorization: kotlin.String? = null) : AccountResponse {
        val localVarResponse = getAccountDetailsApiAccountsAccountIdGetWithHttpInfo(accountId = accountId, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/accounts/{account_id}
     * Get Account Details
     * Get detailed information for a specific account.  - **account_id**: UUID of the account.  Returns account details including the 10 most recent transactions.
     * @param accountId 
     * @param authorization  (optional)
     * @return ApiResponse<AccountResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountDetailsApiAccountsAccountIdGetWithHttpInfo(accountId: java.util.UUID, authorization: kotlin.String?) : ApiResponse<AccountResponse?> {
        val localVariableConfig = getAccountDetailsApiAccountsAccountIdGetRequestConfig(accountId = accountId, authorization = authorization)

        return request<Unit, AccountResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountDetailsApiAccountsAccountIdGet
     *
     * @param accountId 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun getAccountDetailsApiAccountsAccountIdGetRequestConfig(accountId: java.util.UUID, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/accounts/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/accounts/limits
     * Get Account Limits
     * Get current account limits for the authenticated user&#39;s subscription tier.  Returns the limits for each account type, current usage, and upgrade information.
     * @param authorization  (optional)
     * @return AccountLimitsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountLimitsApiAccountsLimitsGet(authorization: kotlin.String? = null) : AccountLimitsResponse {
        val localVarResponse = getAccountLimitsApiAccountsLimitsGetWithHttpInfo(authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountLimitsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/accounts/limits
     * Get Account Limits
     * Get current account limits for the authenticated user&#39;s subscription tier.  Returns the limits for each account type, current usage, and upgrade information.
     * @param authorization  (optional)
     * @return ApiResponse<AccountLimitsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountLimitsApiAccountsLimitsGetWithHttpInfo(authorization: kotlin.String?) : ApiResponse<AccountLimitsResponse?> {
        val localVariableConfig = getAccountLimitsApiAccountsLimitsGetRequestConfig(authorization = authorization)

        return request<Unit, AccountLimitsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountLimitsApiAccountsLimitsGet
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun getAccountLimitsApiAccountsLimitsGetRequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/accounts/limits",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/accounts/link/cex
     * Link Cex Account
     * Link a Centralized Exchange (CEX) account using API credentials. Validates credentials by attempting a connection (or mock validation). Encrypts API secrets before storage.
     * @param cexLinkRequest 
     * @param authorization  (optional)
     * @return AccountResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun linkCexAccountApiAccountsLinkCexPost(cexLinkRequest: CexLinkRequest, authorization: kotlin.String? = null) : AccountResponse {
        val localVarResponse = linkCexAccountApiAccountsLinkCexPostWithHttpInfo(cexLinkRequest = cexLinkRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/accounts/link/cex
     * Link Cex Account
     * Link a Centralized Exchange (CEX) account using API credentials. Validates credentials by attempting a connection (or mock validation). Encrypts API secrets before storage.
     * @param cexLinkRequest 
     * @param authorization  (optional)
     * @return ApiResponse<AccountResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun linkCexAccountApiAccountsLinkCexPostWithHttpInfo(cexLinkRequest: CexLinkRequest, authorization: kotlin.String?) : ApiResponse<AccountResponse?> {
        val localVariableConfig = linkCexAccountApiAccountsLinkCexPostRequestConfig(cexLinkRequest = cexLinkRequest, authorization = authorization)

        return request<CexLinkRequest, AccountResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation linkCexAccountApiAccountsLinkCexPost
     *
     * @param cexLinkRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun linkCexAccountApiAccountsLinkCexPostRequestConfig(cexLinkRequest: CexLinkRequest, authorization: kotlin.String?) : RequestConfig<CexLinkRequest> {
        val localVariableBody = cexLinkRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/accounts/link/cex",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/accounts/link/web3
     * Link Web3 Account
     * Link a Web3 wallet (chain-agnostic). Validates the address format for the provided chain and prevents duplicate linking of the same chain + address by the same user.
     * @param web3LinkRequest 
     * @param authorization  (optional)
     * @return AccountResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun linkWeb3AccountApiAccountsLinkWeb3Post(web3LinkRequest: Web3LinkRequest, authorization: kotlin.String? = null) : AccountResponse {
        val localVarResponse = linkWeb3AccountApiAccountsLinkWeb3PostWithHttpInfo(web3LinkRequest = web3LinkRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/accounts/link/web3
     * Link Web3 Account
     * Link a Web3 wallet (chain-agnostic). Validates the address format for the provided chain and prevents duplicate linking of the same chain + address by the same user.
     * @param web3LinkRequest 
     * @param authorization  (optional)
     * @return ApiResponse<AccountResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun linkWeb3AccountApiAccountsLinkWeb3PostWithHttpInfo(web3LinkRequest: Web3LinkRequest, authorization: kotlin.String?) : ApiResponse<AccountResponse?> {
        val localVariableConfig = linkWeb3AccountApiAccountsLinkWeb3PostRequestConfig(web3LinkRequest = web3LinkRequest, authorization = authorization)

        return request<Web3LinkRequest, AccountResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation linkWeb3AccountApiAccountsLinkWeb3Post
     *
     * @param web3LinkRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun linkWeb3AccountApiAccountsLinkWeb3PostRequestConfig(web3LinkRequest: Web3LinkRequest, authorization: kotlin.String?) : RequestConfig<Web3LinkRequest> {
        val localVariableBody = web3LinkRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/accounts/link/web3",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/accounts
     * List Accounts
     * Retrieve all accounts owned by the authenticated user.  - **account_type**: Optional filter (e.g., &#39;traditional&#39;, &#39;web3&#39;). - **include_balance**: If true, returns current balance (sensitive). - **scope**: &#39;personal&#39; (default) or &#39;household&#39;.  Returns a list of account summaries.
     * @param accountType Optional filter by account_type. (optional)
     * @param includeBalance If false, balance will be omitted to reduce sensitivity. (optional, default to true)
     * @param scope  (optional, default to "personal")
     * @param authorization  (optional)
     * @return kotlin.collections.List<AccountResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listAccountsApiAccountsGet(accountType: kotlin.String? = null, includeBalance: kotlin.Boolean? = true, scope: kotlin.String? = "personal", authorization: kotlin.String? = null) : kotlin.collections.List<AccountResponse> {
        val localVarResponse = listAccountsApiAccountsGetWithHttpInfo(accountType = accountType, includeBalance = includeBalance, scope = scope, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AccountResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/accounts
     * List Accounts
     * Retrieve all accounts owned by the authenticated user.  - **account_type**: Optional filter (e.g., &#39;traditional&#39;, &#39;web3&#39;). - **include_balance**: If true, returns current balance (sensitive). - **scope**: &#39;personal&#39; (default) or &#39;household&#39;.  Returns a list of account summaries.
     * @param accountType Optional filter by account_type. (optional)
     * @param includeBalance If false, balance will be omitted to reduce sensitivity. (optional, default to true)
     * @param scope  (optional, default to "personal")
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.List<AccountResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listAccountsApiAccountsGetWithHttpInfo(accountType: kotlin.String?, includeBalance: kotlin.Boolean?, scope: kotlin.String?, authorization: kotlin.String?) : ApiResponse<kotlin.collections.List<AccountResponse>?> {
        val localVariableConfig = listAccountsApiAccountsGetRequestConfig(accountType = accountType, includeBalance = includeBalance, scope = scope, authorization = authorization)

        return request<Unit, kotlin.collections.List<AccountResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listAccountsApiAccountsGet
     *
     * @param accountType Optional filter by account_type. (optional)
     * @param includeBalance If false, balance will be omitted to reduce sensitivity. (optional, default to true)
     * @param scope  (optional, default to "personal")
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun listAccountsApiAccountsGetRequestConfig(accountType: kotlin.String?, includeBalance: kotlin.Boolean?, scope: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountType != null) {
                    put("account_type", listOf(accountType.toString()))
                }
                if (includeBalance != null) {
                    put("include_balance", listOf(includeBalance.toString()))
                }
                if (scope != null) {
                    put("scope", listOf(scope.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/accounts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/accounts/{account_id}/refresh-metadata
     * Refresh Account Metadata
     * Metadata refresh endpoint for backward compatibility.
     * @param accountId 
     * @param authorization  (optional)
     * @return AccountResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun refreshAccountMetadataApiAccountsAccountIdRefreshMetadataPost(accountId: java.util.UUID, authorization: kotlin.String? = null) : AccountResponse {
        val localVarResponse = refreshAccountMetadataApiAccountsAccountIdRefreshMetadataPostWithHttpInfo(accountId = accountId, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/accounts/{account_id}/refresh-metadata
     * Refresh Account Metadata
     * Metadata refresh endpoint for backward compatibility.
     * @param accountId 
     * @param authorization  (optional)
     * @return ApiResponse<AccountResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun refreshAccountMetadataApiAccountsAccountIdRefreshMetadataPostWithHttpInfo(accountId: java.util.UUID, authorization: kotlin.String?) : ApiResponse<AccountResponse?> {
        val localVariableConfig = refreshAccountMetadataApiAccountsAccountIdRefreshMetadataPostRequestConfig(accountId = accountId, authorization = authorization)

        return request<Unit, AccountResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation refreshAccountMetadataApiAccountsAccountIdRefreshMetadataPost
     *
     * @param accountId 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun refreshAccountMetadataApiAccountsAccountIdRefreshMetadataPostRequestConfig(accountId: java.util.UUID, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/accounts/{account_id}/refresh-metadata".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/accounts/{account_id}/sync
     * Sync Account Transactions
     * Trigger a manual sync of transactions for non-Plaid linked accounts.  - **start_date**: Start of sync window (default: 30 days ago). - **end_date**: End of sync window (default: today). - **initial_sync**: If true, bypasses manual sync limits (internal use only).  Plaid-backed accounts sync automatically via webhooks and cursor jobs. Rate limited for free tier users (unless initial_sync&#x3D;True). Returns sync statistics.
     * @param accountId 
     * @param startDate Start date (inclusive) for the sync window. (optional)
     * @param endDate End date (inclusive) for the sync window. (optional)
     * @param initialSync Bypass limit for initial post-link hydration. (optional, default to false)
     * @param authorization  (optional)
     * @return AccountSyncResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun syncAccountTransactionsApiAccountsAccountIdSyncPost(accountId: java.util.UUID, startDate: java.time.LocalDate? = null, endDate: java.time.LocalDate? = null, initialSync: kotlin.Boolean? = false, authorization: kotlin.String? = null) : AccountSyncResponse {
        val localVarResponse = syncAccountTransactionsApiAccountsAccountIdSyncPostWithHttpInfo(accountId = accountId, startDate = startDate, endDate = endDate, initialSync = initialSync, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountSyncResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/accounts/{account_id}/sync
     * Sync Account Transactions
     * Trigger a manual sync of transactions for non-Plaid linked accounts.  - **start_date**: Start of sync window (default: 30 days ago). - **end_date**: End of sync window (default: today). - **initial_sync**: If true, bypasses manual sync limits (internal use only).  Plaid-backed accounts sync automatically via webhooks and cursor jobs. Rate limited for free tier users (unless initial_sync&#x3D;True). Returns sync statistics.
     * @param accountId 
     * @param startDate Start date (inclusive) for the sync window. (optional)
     * @param endDate End date (inclusive) for the sync window. (optional)
     * @param initialSync Bypass limit for initial post-link hydration. (optional, default to false)
     * @param authorization  (optional)
     * @return ApiResponse<AccountSyncResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun syncAccountTransactionsApiAccountsAccountIdSyncPostWithHttpInfo(accountId: java.util.UUID, startDate: java.time.LocalDate?, endDate: java.time.LocalDate?, initialSync: kotlin.Boolean?, authorization: kotlin.String?) : ApiResponse<AccountSyncResponse?> {
        val localVariableConfig = syncAccountTransactionsApiAccountsAccountIdSyncPostRequestConfig(accountId = accountId, startDate = startDate, endDate = endDate, initialSync = initialSync, authorization = authorization)

        return request<Unit, AccountSyncResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation syncAccountTransactionsApiAccountsAccountIdSyncPost
     *
     * @param accountId 
     * @param startDate Start date (inclusive) for the sync window. (optional)
     * @param endDate End date (inclusive) for the sync window. (optional)
     * @param initialSync Bypass limit for initial post-link hydration. (optional, default to false)
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun syncAccountTransactionsApiAccountsAccountIdSyncPostRequestConfig(accountId: java.util.UUID, startDate: java.time.LocalDate?, endDate: java.time.LocalDate?, initialSync: kotlin.Boolean?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startDate != null) {
                    put("start_date", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("end_date", listOf(parseDateToQueryString(endDate)))
                }
                if (initialSync != null) {
                    put("initial_sync", listOf(initialSync.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/accounts/{account_id}/sync".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PATCH /api/accounts/{account_id}
     * Update Account
     * Update mutable account fields.
     * @param accountId 
     * @param accountUpdate 
     * @param authorization  (optional)
     * @return AccountResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateAccountApiAccountsAccountIdPatch(accountId: java.util.UUID, accountUpdate: AccountUpdate, authorization: kotlin.String? = null) : AccountResponse {
        val localVarResponse = updateAccountApiAccountsAccountIdPatchWithHttpInfo(accountId = accountId, accountUpdate = accountUpdate, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PATCH /api/accounts/{account_id}
     * Update Account
     * Update mutable account fields.
     * @param accountId 
     * @param accountUpdate 
     * @param authorization  (optional)
     * @return ApiResponse<AccountResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateAccountApiAccountsAccountIdPatchWithHttpInfo(accountId: java.util.UUID, accountUpdate: AccountUpdate, authorization: kotlin.String?) : ApiResponse<AccountResponse?> {
        val localVariableConfig = updateAccountApiAccountsAccountIdPatchRequestConfig(accountId = accountId, accountUpdate = accountUpdate, authorization = authorization)

        return request<AccountUpdate, AccountResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateAccountApiAccountsAccountIdPatch
     *
     * @param accountId 
     * @param accountUpdate 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun updateAccountApiAccountsAccountIdPatchRequestConfig(accountId: java.util.UUID, accountUpdate: AccountUpdate, authorization: kotlin.String?) : RequestConfig<AccountUpdate> {
        val localVariableBody = accountUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/accounts/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
