/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.intellifide.jualuma.sharedcore.api.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.intellifide.jualuma.sharedcore.api.models.ChangePasswordRequest
import com.intellifide.jualuma.sharedcore.api.models.DevBootstrapRequest
import com.intellifide.jualuma.sharedcore.api.models.HTTPValidationError
import com.intellifide.jualuma.sharedcore.api.models.MFALabelRequest
import com.intellifide.jualuma.sharedcore.api.models.MFAReauthRequest
import com.intellifide.jualuma.sharedcore.api.models.MFASetPrimaryRequest
import com.intellifide.jualuma.sharedcore.api.models.MFAVerifyRequest
import com.intellifide.jualuma.sharedcore.api.models.PasskeyAuthOptionsRequest
import com.intellifide.jualuma.sharedcore.api.models.PasskeyRegistrationVerifyRequest
import com.intellifide.jualuma.sharedcore.api.models.PendingSignupRequest
import com.intellifide.jualuma.sharedcore.api.models.ProfileUpdateRequest
import com.intellifide.jualuma.sharedcore.api.models.ResetPasswordRequest
import com.intellifide.jualuma.sharedcore.api.models.SignupRequest
import com.intellifide.jualuma.sharedcore.api.models.TokenRequest

import com.squareup.moshi.Json

import com.intellifide.jualuma.sharedcore.api.infrastructure.ApiClient
import com.intellifide.jualuma.sharedcore.api.infrastructure.ApiResponse
import com.intellifide.jualuma.sharedcore.api.infrastructure.ClientException
import com.intellifide.jualuma.sharedcore.api.infrastructure.ClientError
import com.intellifide.jualuma.sharedcore.api.infrastructure.ServerException
import com.intellifide.jualuma.sharedcore.api.infrastructure.ServerError
import com.intellifide.jualuma.sharedcore.api.infrastructure.MultiValueMap
import com.intellifide.jualuma.sharedcore.api.infrastructure.PartConfig
import com.intellifide.jualuma.sharedcore.api.infrastructure.RequestConfig
import com.intellifide.jualuma.sharedcore.api.infrastructure.RequestMethod
import com.intellifide.jualuma.sharedcore.api.infrastructure.ResponseType
import com.intellifide.jualuma.sharedcore.api.infrastructure.Success
import com.intellifide.jualuma.sharedcore.api.infrastructure.toMultiValue

open class AuthApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/auth/change-password
     * Change Password
     * Update password for the logged-in user. Requires current password.
     * @param changePasswordRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun changePasswordApiAuthChangePasswordPost(changePasswordRequest: ChangePasswordRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = changePasswordApiAuthChangePasswordPostWithHttpInfo(changePasswordRequest = changePasswordRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/change-password
     * Change Password
     * Update password for the logged-in user. Requires current password.
     * @param changePasswordRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun changePasswordApiAuthChangePasswordPostWithHttpInfo(changePasswordRequest: ChangePasswordRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = changePasswordApiAuthChangePasswordPostRequestConfig(changePasswordRequest = changePasswordRequest, authorization = authorization)

        return request<ChangePasswordRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation changePasswordApiAuthChangePasswordPost
     *
     * @param changePasswordRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun changePasswordApiAuthChangePasswordPostRequestConfig(changePasswordRequest: ChangePasswordRequest, authorization: kotlin.String?) : RequestConfig<ChangePasswordRequest> {
        val localVariableBody = changePasswordRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/change-password",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/change-password
     * Change Password
     * Update password for the logged-in user. Requires current password.
     * @param changePasswordRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun changePasswordApiAuthChangePasswordPost_0(changePasswordRequest: ChangePasswordRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = changePasswordApiAuthChangePasswordPost_0WithHttpInfo(changePasswordRequest = changePasswordRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/change-password
     * Change Password
     * Update password for the logged-in user. Requires current password.
     * @param changePasswordRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun changePasswordApiAuthChangePasswordPost_0WithHttpInfo(changePasswordRequest: ChangePasswordRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = changePasswordApiAuthChangePasswordPost_0RequestConfig(changePasswordRequest = changePasswordRequest, authorization = authorization)

        return request<ChangePasswordRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation changePasswordApiAuthChangePasswordPost_0
     *
     * @param changePasswordRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun changePasswordApiAuthChangePasswordPost_0RequestConfig(changePasswordRequest: ChangePasswordRequest, authorization: kotlin.String?) : RequestConfig<ChangePasswordRequest> {
        val localVariableBody = changePasswordRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/change-password",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/dev/bootstrap
     * Dev Bootstrap User
     * LOCAL/TEST ONLY: Ensure a User row exists for the authenticated identity.  This exists to support deterministic API smoke tests (e.g., automated CI collections) without requiring OTP + browser flows.
     * @param devBootstrapRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devBootstrapUserApiAuthDevBootstrapPost(devBootstrapRequest: DevBootstrapRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = devBootstrapUserApiAuthDevBootstrapPostWithHttpInfo(devBootstrapRequest = devBootstrapRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/dev/bootstrap
     * Dev Bootstrap User
     * LOCAL/TEST ONLY: Ensure a User row exists for the authenticated identity.  This exists to support deterministic API smoke tests (e.g., automated CI collections) without requiring OTP + browser flows.
     * @param devBootstrapRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun devBootstrapUserApiAuthDevBootstrapPostWithHttpInfo(devBootstrapRequest: DevBootstrapRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = devBootstrapUserApiAuthDevBootstrapPostRequestConfig(devBootstrapRequest = devBootstrapRequest, authorization = authorization)

        return request<DevBootstrapRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation devBootstrapUserApiAuthDevBootstrapPost
     *
     * @param devBootstrapRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun devBootstrapUserApiAuthDevBootstrapPostRequestConfig(devBootstrapRequest: DevBootstrapRequest, authorization: kotlin.String?) : RequestConfig<DevBootstrapRequest> {
        val localVariableBody = devBootstrapRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/dev/bootstrap",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/dev/bootstrap
     * Dev Bootstrap User
     * LOCAL/TEST ONLY: Ensure a User row exists for the authenticated identity.  This exists to support deterministic API smoke tests (e.g., automated CI collections) without requiring OTP + browser flows.
     * @param devBootstrapRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devBootstrapUserApiAuthDevBootstrapPost_0(devBootstrapRequest: DevBootstrapRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = devBootstrapUserApiAuthDevBootstrapPost_0WithHttpInfo(devBootstrapRequest = devBootstrapRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/dev/bootstrap
     * Dev Bootstrap User
     * LOCAL/TEST ONLY: Ensure a User row exists for the authenticated identity.  This exists to support deterministic API smoke tests (e.g., automated CI collections) without requiring OTP + browser flows.
     * @param devBootstrapRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun devBootstrapUserApiAuthDevBootstrapPost_0WithHttpInfo(devBootstrapRequest: DevBootstrapRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = devBootstrapUserApiAuthDevBootstrapPost_0RequestConfig(devBootstrapRequest = devBootstrapRequest, authorization = authorization)

        return request<DevBootstrapRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation devBootstrapUserApiAuthDevBootstrapPost_0
     *
     * @param devBootstrapRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun devBootstrapUserApiAuthDevBootstrapPost_0RequestConfig(devBootstrapRequest: DevBootstrapRequest, authorization: kotlin.String?) : RequestConfig<DevBootstrapRequest> {
        val localVariableBody = devBootstrapRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/dev/bootstrap",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/email/enable
     * Enable Email Mfa
     * Enable Email MFA by verifying a sent code.
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enableEmailMfaApiAuthMfaEmailEnablePost(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = enableEmailMfaApiAuthMfaEmailEnablePostWithHttpInfo(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/email/enable
     * Enable Email Mfa
     * Enable Email MFA by verifying a sent code.
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enableEmailMfaApiAuthMfaEmailEnablePostWithHttpInfo(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = enableEmailMfaApiAuthMfaEmailEnablePostRequestConfig(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return request<MFAVerifyRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation enableEmailMfaApiAuthMfaEmailEnablePost
     *
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun enableEmailMfaApiAuthMfaEmailEnablePostRequestConfig(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : RequestConfig<MFAVerifyRequest> {
        val localVariableBody = mfAVerifyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/email/enable",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/email/enable
     * Enable Email Mfa
     * Enable Email MFA by verifying a sent code.
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enableEmailMfaApiAuthMfaEmailEnablePost_0(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = enableEmailMfaApiAuthMfaEmailEnablePost_0WithHttpInfo(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/email/enable
     * Enable Email Mfa
     * Enable Email MFA by verifying a sent code.
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enableEmailMfaApiAuthMfaEmailEnablePost_0WithHttpInfo(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = enableEmailMfaApiAuthMfaEmailEnablePost_0RequestConfig(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return request<MFAVerifyRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation enableEmailMfaApiAuthMfaEmailEnablePost_0
     *
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun enableEmailMfaApiAuthMfaEmailEnablePost_0RequestConfig(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : RequestConfig<MFAVerifyRequest> {
        val localVariableBody = mfAVerifyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/email/enable",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/auth/sessions
     * End Other Sessions
     * Terminate all sessions except the current one.
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun endOtherSessionsApiAuthSessionsDelete(authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = endOtherSessionsApiAuthSessionsDeleteWithHttpInfo(authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/auth/sessions
     * End Other Sessions
     * Terminate all sessions except the current one.
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun endOtherSessionsApiAuthSessionsDeleteWithHttpInfo(authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = endOtherSessionsApiAuthSessionsDeleteRequestConfig(authorization = authorization)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation endOtherSessionsApiAuthSessionsDelete
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun endOtherSessionsApiAuthSessionsDeleteRequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/auth/sessions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/auth/sessions
     * End Other Sessions
     * Terminate all sessions except the current one.
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun endOtherSessionsApiAuthSessionsDelete_0(authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = endOtherSessionsApiAuthSessionsDelete_0WithHttpInfo(authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/auth/sessions
     * End Other Sessions
     * Terminate all sessions except the current one.
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun endOtherSessionsApiAuthSessionsDelete_0WithHttpInfo(authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = endOtherSessionsApiAuthSessionsDelete_0RequestConfig(authorization = authorization)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation endOtherSessionsApiAuthSessionsDelete_0
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun endOtherSessionsApiAuthSessionsDelete_0RequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/auth/sessions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/auth/sessions/{session_id}
     * End Session
     * Terminate a specific session.
     * @param sessionId 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun endSessionApiAuthSessionsSessionIdDelete(sessionId: java.util.UUID, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = endSessionApiAuthSessionsSessionIdDeleteWithHttpInfo(sessionId = sessionId, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/auth/sessions/{session_id}
     * End Session
     * Terminate a specific session.
     * @param sessionId 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun endSessionApiAuthSessionsSessionIdDeleteWithHttpInfo(sessionId: java.util.UUID, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = endSessionApiAuthSessionsSessionIdDeleteRequestConfig(sessionId = sessionId, authorization = authorization)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation endSessionApiAuthSessionsSessionIdDelete
     *
     * @param sessionId 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun endSessionApiAuthSessionsSessionIdDeleteRequestConfig(sessionId: java.util.UUID, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/auth/sessions/{session_id}".replace("{"+"session_id"+"}", encodeURIComponent(sessionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/auth/sessions/{session_id}
     * End Session
     * Terminate a specific session.
     * @param sessionId 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun endSessionApiAuthSessionsSessionIdDelete_0(sessionId: java.util.UUID, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = endSessionApiAuthSessionsSessionIdDelete_0WithHttpInfo(sessionId = sessionId, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/auth/sessions/{session_id}
     * End Session
     * Terminate a specific session.
     * @param sessionId 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun endSessionApiAuthSessionsSessionIdDelete_0WithHttpInfo(sessionId: java.util.UUID, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = endSessionApiAuthSessionsSessionIdDelete_0RequestConfig(sessionId = sessionId, authorization = authorization)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation endSessionApiAuthSessionsSessionIdDelete_0
     *
     * @param sessionId 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun endSessionApiAuthSessionsSessionIdDelete_0RequestConfig(sessionId: java.util.UUID, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/auth/sessions/{session_id}".replace("{"+"session_id"+"}", encodeURIComponent(sessionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/auth/profile
     * Get Profile
     * Return the authenticated user&#39;s profile with preferences and subscriptions.
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getProfileApiAuthProfileGet(authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = getProfileApiAuthProfileGetWithHttpInfo(authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/auth/profile
     * Get Profile
     * Return the authenticated user&#39;s profile with preferences and subscriptions.
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getProfileApiAuthProfileGetWithHttpInfo(authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = getProfileApiAuthProfileGetRequestConfig(authorization = authorization)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getProfileApiAuthProfileGet
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun getProfileApiAuthProfileGetRequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/auth/profile",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/auth/profile
     * Get Profile
     * Return the authenticated user&#39;s profile with preferences and subscriptions.
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getProfileApiAuthProfileGet_0(authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = getProfileApiAuthProfileGet_0WithHttpInfo(authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/auth/profile
     * Get Profile
     * Return the authenticated user&#39;s profile with preferences and subscriptions.
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getProfileApiAuthProfileGet_0WithHttpInfo(authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = getProfileApiAuthProfileGet_0RequestConfig(authorization = authorization)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getProfileApiAuthProfileGet_0
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun getProfileApiAuthProfileGet_0RequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/auth/profile",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/auth/sessions
     * List Sessions
     * List all sessions for the current user.
     * @param authorization  (optional)
     * @return kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listSessionsApiAuthSessionsGet(authorization: kotlin.String? = null) : kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>> {
        val localVarResponse = listSessionsApiAuthSessionsGetWithHttpInfo(authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/auth/sessions
     * List Sessions
     * List all sessions for the current user.
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listSessionsApiAuthSessionsGetWithHttpInfo(authorization: kotlin.String?) : ApiResponse<kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>>?> {
        val localVariableConfig = listSessionsApiAuthSessionsGetRequestConfig(authorization = authorization)

        return request<Unit, kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listSessionsApiAuthSessionsGet
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun listSessionsApiAuthSessionsGetRequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/auth/sessions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/auth/sessions
     * List Sessions
     * List all sessions for the current user.
     * @param authorization  (optional)
     * @return kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listSessionsApiAuthSessionsGet_0(authorization: kotlin.String? = null) : kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>> {
        val localVarResponse = listSessionsApiAuthSessionsGet_0WithHttpInfo(authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/auth/sessions
     * List Sessions
     * List all sessions for the current user.
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listSessionsApiAuthSessionsGet_0WithHttpInfo(authorization: kotlin.String?) : ApiResponse<kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>>?> {
        val localVariableConfig = listSessionsApiAuthSessionsGet_0RequestConfig(authorization = authorization)

        return request<Unit, kotlin.collections.List<kotlin.collections.Map<kotlin.String, kotlin.Any>>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listSessionsApiAuthSessionsGet_0
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun listSessionsApiAuthSessionsGet_0RequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/auth/sessions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/login
     * Login
     * Exchange a valid Identity ID token for a user session profile.  - **token**: The JWT ID token from the client SDK.  Returns the full user profile including subscription status.
     * @param tokenRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginApiAuthLoginPost(tokenRequest: TokenRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = loginApiAuthLoginPostWithHttpInfo(tokenRequest = tokenRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/login
     * Login
     * Exchange a valid Identity ID token for a user session profile.  - **token**: The JWT ID token from the client SDK.  Returns the full user profile including subscription status.
     * @param tokenRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginApiAuthLoginPostWithHttpInfo(tokenRequest: TokenRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = loginApiAuthLoginPostRequestConfig(tokenRequest = tokenRequest)

        return request<TokenRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginApiAuthLoginPost
     *
     * @param tokenRequest 
     * @return RequestConfig
     */
    fun loginApiAuthLoginPostRequestConfig(tokenRequest: TokenRequest) : RequestConfig<TokenRequest> {
        val localVariableBody = tokenRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/login",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/login
     * Login
     * Exchange a valid Identity ID token for a user session profile.  - **token**: The JWT ID token from the client SDK.  Returns the full user profile including subscription status.
     * @param tokenRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginApiAuthLoginPost_0(tokenRequest: TokenRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = loginApiAuthLoginPost_0WithHttpInfo(tokenRequest = tokenRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/login
     * Login
     * Exchange a valid Identity ID token for a user session profile.  - **token**: The JWT ID token from the client SDK.  Returns the full user profile including subscription status.
     * @param tokenRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginApiAuthLoginPost_0WithHttpInfo(tokenRequest: TokenRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = loginApiAuthLoginPost_0RequestConfig(tokenRequest = tokenRequest)

        return request<TokenRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginApiAuthLoginPost_0
     *
     * @param tokenRequest 
     * @return RequestConfig
     */
    fun loginApiAuthLoginPost_0RequestConfig(tokenRequest: TokenRequest) : RequestConfig<TokenRequest> {
        val localVariableBody = tokenRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/login",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/logout
     * Logout
     * 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun logoutApiAuthLogoutPost(authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = logoutApiAuthLogoutPostWithHttpInfo(authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/logout
     * Logout
     * 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun logoutApiAuthLogoutPostWithHttpInfo(authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = logoutApiAuthLogoutPostRequestConfig(authorization = authorization)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation logoutApiAuthLogoutPost
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun logoutApiAuthLogoutPostRequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/logout",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/logout
     * Logout
     * 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun logoutApiAuthLogoutPost_0(authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = logoutApiAuthLogoutPost_0WithHttpInfo(authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/logout
     * Logout
     * 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun logoutApiAuthLogoutPost_0WithHttpInfo(authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = logoutApiAuthLogoutPost_0RequestConfig(authorization = authorization)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation logoutApiAuthLogoutPost_0
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun logoutApiAuthLogoutPost_0RequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/logout",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/disable
     * Mfa Disable
     * Disable MFA (requires valid code as confirmation).
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mfaDisableApiAuthMfaDisablePost(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = mfaDisableApiAuthMfaDisablePostWithHttpInfo(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/disable
     * Mfa Disable
     * Disable MFA (requires valid code as confirmation).
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mfaDisableApiAuthMfaDisablePostWithHttpInfo(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = mfaDisableApiAuthMfaDisablePostRequestConfig(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return request<MFAVerifyRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mfaDisableApiAuthMfaDisablePost
     *
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun mfaDisableApiAuthMfaDisablePostRequestConfig(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : RequestConfig<MFAVerifyRequest> {
        val localVariableBody = mfAVerifyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/disable",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/disable
     * Mfa Disable
     * Disable MFA (requires valid code as confirmation).
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mfaDisableApiAuthMfaDisablePost_0(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = mfaDisableApiAuthMfaDisablePost_0WithHttpInfo(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/disable
     * Mfa Disable
     * Disable MFA (requires valid code as confirmation).
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mfaDisableApiAuthMfaDisablePost_0WithHttpInfo(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = mfaDisableApiAuthMfaDisablePost_0RequestConfig(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return request<MFAVerifyRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mfaDisableApiAuthMfaDisablePost_0
     *
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun mfaDisableApiAuthMfaDisablePost_0RequestConfig(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : RequestConfig<MFAVerifyRequest> {
        val localVariableBody = mfAVerifyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/disable",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/enable
     * Mfa Enable
     * Verify and enable MFA.
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mfaEnableApiAuthMfaEnablePost(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = mfaEnableApiAuthMfaEnablePostWithHttpInfo(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/enable
     * Mfa Enable
     * Verify and enable MFA.
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mfaEnableApiAuthMfaEnablePostWithHttpInfo(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = mfaEnableApiAuthMfaEnablePostRequestConfig(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return request<MFAVerifyRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mfaEnableApiAuthMfaEnablePost
     *
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun mfaEnableApiAuthMfaEnablePostRequestConfig(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : RequestConfig<MFAVerifyRequest> {
        val localVariableBody = mfAVerifyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/enable",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/enable
     * Mfa Enable
     * Verify and enable MFA.
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mfaEnableApiAuthMfaEnablePost_0(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = mfaEnableApiAuthMfaEnablePost_0WithHttpInfo(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/enable
     * Mfa Enable
     * Verify and enable MFA.
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mfaEnableApiAuthMfaEnablePost_0WithHttpInfo(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = mfaEnableApiAuthMfaEnablePost_0RequestConfig(mfAVerifyRequest = mfAVerifyRequest, authorization = authorization)

        return request<MFAVerifyRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mfaEnableApiAuthMfaEnablePost_0
     *
     * @param mfAVerifyRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun mfaEnableApiAuthMfaEnablePost_0RequestConfig(mfAVerifyRequest: MFAVerifyRequest, authorization: kotlin.String?) : RequestConfig<MFAVerifyRequest> {
        val localVariableBody = mfAVerifyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/enable",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/label
     * Mfa Set Label
     * Set a user-friendly label for an enabled MFA method.
     * @param mfALabelRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mfaSetLabelApiAuthMfaLabelPost(mfALabelRequest: MFALabelRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = mfaSetLabelApiAuthMfaLabelPostWithHttpInfo(mfALabelRequest = mfALabelRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/label
     * Mfa Set Label
     * Set a user-friendly label for an enabled MFA method.
     * @param mfALabelRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mfaSetLabelApiAuthMfaLabelPostWithHttpInfo(mfALabelRequest: MFALabelRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = mfaSetLabelApiAuthMfaLabelPostRequestConfig(mfALabelRequest = mfALabelRequest, authorization = authorization)

        return request<MFALabelRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mfaSetLabelApiAuthMfaLabelPost
     *
     * @param mfALabelRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun mfaSetLabelApiAuthMfaLabelPostRequestConfig(mfALabelRequest: MFALabelRequest, authorization: kotlin.String?) : RequestConfig<MFALabelRequest> {
        val localVariableBody = mfALabelRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/label",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/label
     * Mfa Set Label
     * Set a user-friendly label for an enabled MFA method.
     * @param mfALabelRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mfaSetLabelApiAuthMfaLabelPost_0(mfALabelRequest: MFALabelRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = mfaSetLabelApiAuthMfaLabelPost_0WithHttpInfo(mfALabelRequest = mfALabelRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/label
     * Mfa Set Label
     * Set a user-friendly label for an enabled MFA method.
     * @param mfALabelRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mfaSetLabelApiAuthMfaLabelPost_0WithHttpInfo(mfALabelRequest: MFALabelRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = mfaSetLabelApiAuthMfaLabelPost_0RequestConfig(mfALabelRequest = mfALabelRequest, authorization = authorization)

        return request<MFALabelRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mfaSetLabelApiAuthMfaLabelPost_0
     *
     * @param mfALabelRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun mfaSetLabelApiAuthMfaLabelPost_0RequestConfig(mfALabelRequest: MFALabelRequest, authorization: kotlin.String?) : RequestConfig<MFALabelRequest> {
        val localVariableBody = mfALabelRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/label",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/primary
     * Mfa Set Primary
     * Set which MFA method is required (primary) when multiple methods are configured.
     * @param mfASetPrimaryRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mfaSetPrimaryApiAuthMfaPrimaryPost(mfASetPrimaryRequest: MFASetPrimaryRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = mfaSetPrimaryApiAuthMfaPrimaryPostWithHttpInfo(mfASetPrimaryRequest = mfASetPrimaryRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/primary
     * Mfa Set Primary
     * Set which MFA method is required (primary) when multiple methods are configured.
     * @param mfASetPrimaryRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mfaSetPrimaryApiAuthMfaPrimaryPostWithHttpInfo(mfASetPrimaryRequest: MFASetPrimaryRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = mfaSetPrimaryApiAuthMfaPrimaryPostRequestConfig(mfASetPrimaryRequest = mfASetPrimaryRequest, authorization = authorization)

        return request<MFASetPrimaryRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mfaSetPrimaryApiAuthMfaPrimaryPost
     *
     * @param mfASetPrimaryRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun mfaSetPrimaryApiAuthMfaPrimaryPostRequestConfig(mfASetPrimaryRequest: MFASetPrimaryRequest, authorization: kotlin.String?) : RequestConfig<MFASetPrimaryRequest> {
        val localVariableBody = mfASetPrimaryRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/primary",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/primary
     * Mfa Set Primary
     * Set which MFA method is required (primary) when multiple methods are configured.
     * @param mfASetPrimaryRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mfaSetPrimaryApiAuthMfaPrimaryPost_0(mfASetPrimaryRequest: MFASetPrimaryRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = mfaSetPrimaryApiAuthMfaPrimaryPost_0WithHttpInfo(mfASetPrimaryRequest = mfASetPrimaryRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/primary
     * Mfa Set Primary
     * Set which MFA method is required (primary) when multiple methods are configured.
     * @param mfASetPrimaryRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mfaSetPrimaryApiAuthMfaPrimaryPost_0WithHttpInfo(mfASetPrimaryRequest: MFASetPrimaryRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = mfaSetPrimaryApiAuthMfaPrimaryPost_0RequestConfig(mfASetPrimaryRequest = mfASetPrimaryRequest, authorization = authorization)

        return request<MFASetPrimaryRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mfaSetPrimaryApiAuthMfaPrimaryPost_0
     *
     * @param mfASetPrimaryRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun mfaSetPrimaryApiAuthMfaPrimaryPost_0RequestConfig(mfASetPrimaryRequest: MFASetPrimaryRequest, authorization: kotlin.String?) : RequestConfig<MFASetPrimaryRequest> {
        val localVariableBody = mfASetPrimaryRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/primary",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/setup
     * Mfa Setup
     * Generate a new TOTP secret for the user.
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mfaSetupApiAuthMfaSetupPost(authorization: kotlin.String? = null, mfAReauthRequest: MFAReauthRequest? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = mfaSetupApiAuthMfaSetupPostWithHttpInfo(authorization = authorization, mfAReauthRequest = mfAReauthRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/setup
     * Mfa Setup
     * Generate a new TOTP secret for the user.
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mfaSetupApiAuthMfaSetupPostWithHttpInfo(authorization: kotlin.String?, mfAReauthRequest: MFAReauthRequest?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = mfaSetupApiAuthMfaSetupPostRequestConfig(authorization = authorization, mfAReauthRequest = mfAReauthRequest)

        return request<MFAReauthRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mfaSetupApiAuthMfaSetupPost
     *
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return RequestConfig
     */
    fun mfaSetupApiAuthMfaSetupPostRequestConfig(authorization: kotlin.String?, mfAReauthRequest: MFAReauthRequest?) : RequestConfig<MFAReauthRequest> {
        val localVariableBody = mfAReauthRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/setup",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/setup
     * Mfa Setup
     * Generate a new TOTP secret for the user.
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mfaSetupApiAuthMfaSetupPost_0(authorization: kotlin.String? = null, mfAReauthRequest: MFAReauthRequest? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = mfaSetupApiAuthMfaSetupPost_0WithHttpInfo(authorization = authorization, mfAReauthRequest = mfAReauthRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/setup
     * Mfa Setup
     * Generate a new TOTP secret for the user.
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mfaSetupApiAuthMfaSetupPost_0WithHttpInfo(authorization: kotlin.String?, mfAReauthRequest: MFAReauthRequest?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = mfaSetupApiAuthMfaSetupPost_0RequestConfig(authorization = authorization, mfAReauthRequest = mfAReauthRequest)

        return request<MFAReauthRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mfaSetupApiAuthMfaSetupPost_0
     *
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return RequestConfig
     */
    fun mfaSetupApiAuthMfaSetupPost_0RequestConfig(authorization: kotlin.String?, mfAReauthRequest: MFAReauthRequest?) : RequestConfig<MFAReauthRequest> {
        val localVariableBody = mfAReauthRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/setup",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/passkey/auth/options
     * Passkey Auth Options
     * 
     * @param passkeyAuthOptionsRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPost(passkeyAuthOptionsRequest: PasskeyAuthOptionsRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPostWithHttpInfo(passkeyAuthOptionsRequest = passkeyAuthOptionsRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/passkey/auth/options
     * Passkey Auth Options
     * 
     * @param passkeyAuthOptionsRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPostWithHttpInfo(passkeyAuthOptionsRequest: PasskeyAuthOptionsRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPostRequestConfig(passkeyAuthOptionsRequest = passkeyAuthOptionsRequest)

        return request<PasskeyAuthOptionsRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPost
     *
     * @param passkeyAuthOptionsRequest 
     * @return RequestConfig
     */
    fun passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPostRequestConfig(passkeyAuthOptionsRequest: PasskeyAuthOptionsRequest) : RequestConfig<PasskeyAuthOptionsRequest> {
        val localVariableBody = passkeyAuthOptionsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/passkey/auth/options",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/passkey/auth/options
     * Passkey Auth Options
     * 
     * @param passkeyAuthOptionsRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPost_0(passkeyAuthOptionsRequest: PasskeyAuthOptionsRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPost_0WithHttpInfo(passkeyAuthOptionsRequest = passkeyAuthOptionsRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/passkey/auth/options
     * Passkey Auth Options
     * 
     * @param passkeyAuthOptionsRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPost_0WithHttpInfo(passkeyAuthOptionsRequest: PasskeyAuthOptionsRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPost_0RequestConfig(passkeyAuthOptionsRequest = passkeyAuthOptionsRequest)

        return request<PasskeyAuthOptionsRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPost_0
     *
     * @param passkeyAuthOptionsRequest 
     * @return RequestConfig
     */
    fun passkeyAuthOptionsApiAuthMfaPasskeyAuthOptionsPost_0RequestConfig(passkeyAuthOptionsRequest: PasskeyAuthOptionsRequest) : RequestConfig<PasskeyAuthOptionsRequest> {
        val localVariableBody = passkeyAuthOptionsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/passkey/auth/options",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/passkey/register/options
     * Passkey Register Options
     * 
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPost(authorization: kotlin.String? = null, mfAReauthRequest: MFAReauthRequest? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPostWithHttpInfo(authorization = authorization, mfAReauthRequest = mfAReauthRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/passkey/register/options
     * Passkey Register Options
     * 
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPostWithHttpInfo(authorization: kotlin.String?, mfAReauthRequest: MFAReauthRequest?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPostRequestConfig(authorization = authorization, mfAReauthRequest = mfAReauthRequest)

        return request<MFAReauthRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPost
     *
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return RequestConfig
     */
    fun passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPostRequestConfig(authorization: kotlin.String?, mfAReauthRequest: MFAReauthRequest?) : RequestConfig<MFAReauthRequest> {
        val localVariableBody = mfAReauthRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/passkey/register/options",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/passkey/register/options
     * Passkey Register Options
     * 
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPost_0(authorization: kotlin.String? = null, mfAReauthRequest: MFAReauthRequest? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPost_0WithHttpInfo(authorization = authorization, mfAReauthRequest = mfAReauthRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/passkey/register/options
     * Passkey Register Options
     * 
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPost_0WithHttpInfo(authorization: kotlin.String?, mfAReauthRequest: MFAReauthRequest?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPost_0RequestConfig(authorization = authorization, mfAReauthRequest = mfAReauthRequest)

        return request<MFAReauthRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPost_0
     *
     * @param authorization  (optional)
     * @param mfAReauthRequest  (optional)
     * @return RequestConfig
     */
    fun passkeyRegisterOptionsApiAuthMfaPasskeyRegisterOptionsPost_0RequestConfig(authorization: kotlin.String?, mfAReauthRequest: MFAReauthRequest?) : RequestConfig<MFAReauthRequest> {
        val localVariableBody = mfAReauthRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/passkey/register/options",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/passkey/register/verify
     * Passkey Register Verify
     * 
     * @param passkeyRegistrationVerifyRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPost(passkeyRegistrationVerifyRequest: PasskeyRegistrationVerifyRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPostWithHttpInfo(passkeyRegistrationVerifyRequest = passkeyRegistrationVerifyRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/passkey/register/verify
     * Passkey Register Verify
     * 
     * @param passkeyRegistrationVerifyRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPostWithHttpInfo(passkeyRegistrationVerifyRequest: PasskeyRegistrationVerifyRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPostRequestConfig(passkeyRegistrationVerifyRequest = passkeyRegistrationVerifyRequest, authorization = authorization)

        return request<PasskeyRegistrationVerifyRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPost
     *
     * @param passkeyRegistrationVerifyRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPostRequestConfig(passkeyRegistrationVerifyRequest: PasskeyRegistrationVerifyRequest, authorization: kotlin.String?) : RequestConfig<PasskeyRegistrationVerifyRequest> {
        val localVariableBody = passkeyRegistrationVerifyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/passkey/register/verify",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/passkey/register/verify
     * Passkey Register Verify
     * 
     * @param passkeyRegistrationVerifyRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPost_0(passkeyRegistrationVerifyRequest: PasskeyRegistrationVerifyRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPost_0WithHttpInfo(passkeyRegistrationVerifyRequest = passkeyRegistrationVerifyRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/passkey/register/verify
     * Passkey Register Verify
     * 
     * @param passkeyRegistrationVerifyRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPost_0WithHttpInfo(passkeyRegistrationVerifyRequest: PasskeyRegistrationVerifyRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPost_0RequestConfig(passkeyRegistrationVerifyRequest = passkeyRegistrationVerifyRequest, authorization = authorization)

        return request<PasskeyRegistrationVerifyRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPost_0
     *
     * @param passkeyRegistrationVerifyRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun passkeyRegisterVerifyApiAuthMfaPasskeyRegisterVerifyPost_0RequestConfig(passkeyRegistrationVerifyRequest: PasskeyRegistrationVerifyRequest, authorization: kotlin.String?) : RequestConfig<PasskeyRegistrationVerifyRequest> {
        val localVariableBody = passkeyRegistrationVerifyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/passkey/register/verify",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/email/request-code
     * Request Email Code
     * Request an Email OTP for login or setup.
     * @param resetPasswordRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestEmailCodeApiAuthMfaEmailRequestCodePost(resetPasswordRequest: ResetPasswordRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = requestEmailCodeApiAuthMfaEmailRequestCodePostWithHttpInfo(resetPasswordRequest = resetPasswordRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/email/request-code
     * Request Email Code
     * Request an Email OTP for login or setup.
     * @param resetPasswordRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun requestEmailCodeApiAuthMfaEmailRequestCodePostWithHttpInfo(resetPasswordRequest: ResetPasswordRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = requestEmailCodeApiAuthMfaEmailRequestCodePostRequestConfig(resetPasswordRequest = resetPasswordRequest)

        return request<ResetPasswordRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation requestEmailCodeApiAuthMfaEmailRequestCodePost
     *
     * @param resetPasswordRequest 
     * @return RequestConfig
     */
    fun requestEmailCodeApiAuthMfaEmailRequestCodePostRequestConfig(resetPasswordRequest: ResetPasswordRequest) : RequestConfig<ResetPasswordRequest> {
        val localVariableBody = resetPasswordRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/email/request-code",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/mfa/email/request-code
     * Request Email Code
     * Request an Email OTP for login or setup.
     * @param resetPasswordRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestEmailCodeApiAuthMfaEmailRequestCodePost_0(resetPasswordRequest: ResetPasswordRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = requestEmailCodeApiAuthMfaEmailRequestCodePost_0WithHttpInfo(resetPasswordRequest = resetPasswordRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/mfa/email/request-code
     * Request Email Code
     * Request an Email OTP for login or setup.
     * @param resetPasswordRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun requestEmailCodeApiAuthMfaEmailRequestCodePost_0WithHttpInfo(resetPasswordRequest: ResetPasswordRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = requestEmailCodeApiAuthMfaEmailRequestCodePost_0RequestConfig(resetPasswordRequest = resetPasswordRequest)

        return request<ResetPasswordRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation requestEmailCodeApiAuthMfaEmailRequestCodePost_0
     *
     * @param resetPasswordRequest 
     * @return RequestConfig
     */
    fun requestEmailCodeApiAuthMfaEmailRequestCodePost_0RequestConfig(resetPasswordRequest: ResetPasswordRequest) : RequestConfig<ResetPasswordRequest> {
        val localVariableBody = resetPasswordRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/mfa/email/request-code",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/reset-password
     * Reset Password
     * Generate and dispatch a password reset link. Enforces MFA if enabled.
     * @param resetPasswordRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun resetPasswordApiAuthResetPasswordPost(resetPasswordRequest: ResetPasswordRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = resetPasswordApiAuthResetPasswordPostWithHttpInfo(resetPasswordRequest = resetPasswordRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/reset-password
     * Reset Password
     * Generate and dispatch a password reset link. Enforces MFA if enabled.
     * @param resetPasswordRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun resetPasswordApiAuthResetPasswordPostWithHttpInfo(resetPasswordRequest: ResetPasswordRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = resetPasswordApiAuthResetPasswordPostRequestConfig(resetPasswordRequest = resetPasswordRequest)

        return request<ResetPasswordRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation resetPasswordApiAuthResetPasswordPost
     *
     * @param resetPasswordRequest 
     * @return RequestConfig
     */
    fun resetPasswordApiAuthResetPasswordPostRequestConfig(resetPasswordRequest: ResetPasswordRequest) : RequestConfig<ResetPasswordRequest> {
        val localVariableBody = resetPasswordRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/reset-password",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/reset-password
     * Reset Password
     * Generate and dispatch a password reset link. Enforces MFA if enabled.
     * @param resetPasswordRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun resetPasswordApiAuthResetPasswordPost_0(resetPasswordRequest: ResetPasswordRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = resetPasswordApiAuthResetPasswordPost_0WithHttpInfo(resetPasswordRequest = resetPasswordRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/reset-password
     * Reset Password
     * Generate and dispatch a password reset link. Enforces MFA if enabled.
     * @param resetPasswordRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun resetPasswordApiAuthResetPasswordPost_0WithHttpInfo(resetPasswordRequest: ResetPasswordRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = resetPasswordApiAuthResetPasswordPost_0RequestConfig(resetPasswordRequest = resetPasswordRequest)

        return request<ResetPasswordRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation resetPasswordApiAuthResetPasswordPost_0
     *
     * @param resetPasswordRequest 
     * @return RequestConfig
     */
    fun resetPasswordApiAuthResetPasswordPost_0RequestConfig(resetPasswordRequest: ResetPasswordRequest) : RequestConfig<ResetPasswordRequest> {
        val localVariableBody = resetPasswordRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/reset-password",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/signup
     * Signup
     * Register a new user in Identity Platform and the local database.  - **email**: Valid email address. - **password**: Password (min 8 chars).  Returns the new user&#39;s UID and email.
     * @param signupRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun signupApiAuthSignupPost(signupRequest: SignupRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = signupApiAuthSignupPostWithHttpInfo(signupRequest = signupRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/signup
     * Signup
     * Register a new user in Identity Platform and the local database.  - **email**: Valid email address. - **password**: Password (min 8 chars).  Returns the new user&#39;s UID and email.
     * @param signupRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun signupApiAuthSignupPostWithHttpInfo(signupRequest: SignupRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = signupApiAuthSignupPostRequestConfig(signupRequest = signupRequest)

        return request<SignupRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation signupApiAuthSignupPost
     *
     * @param signupRequest 
     * @return RequestConfig
     */
    fun signupApiAuthSignupPostRequestConfig(signupRequest: SignupRequest) : RequestConfig<SignupRequest> {
        val localVariableBody = signupRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/signup",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/signup
     * Signup
     * Register a new user in Identity Platform and the local database.  - **email**: Valid email address. - **password**: Password (min 8 chars).  Returns the new user&#39;s UID and email.
     * @param signupRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun signupApiAuthSignupPost_0(signupRequest: SignupRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = signupApiAuthSignupPost_0WithHttpInfo(signupRequest = signupRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/signup
     * Signup
     * Register a new user in Identity Platform and the local database.  - **email**: Valid email address. - **password**: Password (min 8 chars).  Returns the new user&#39;s UID and email.
     * @param signupRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun signupApiAuthSignupPost_0WithHttpInfo(signupRequest: SignupRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = signupApiAuthSignupPost_0RequestConfig(signupRequest = signupRequest)

        return request<SignupRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation signupApiAuthSignupPost_0
     *
     * @param signupRequest 
     * @return RequestConfig
     */
    fun signupApiAuthSignupPost_0RequestConfig(signupRequest: SignupRequest) : RequestConfig<SignupRequest> {
        val localVariableBody = signupRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/signup",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/signup/pending
     * Signup Pending
     * Store temporary signup data after Identity Platform user creation.  Requires a valid Identity ID token.
     * @param pendingSignupRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun signupPendingApiAuthSignupPendingPost(pendingSignupRequest: PendingSignupRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = signupPendingApiAuthSignupPendingPostWithHttpInfo(pendingSignupRequest = pendingSignupRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/signup/pending
     * Signup Pending
     * Store temporary signup data after Identity Platform user creation.  Requires a valid Identity ID token.
     * @param pendingSignupRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun signupPendingApiAuthSignupPendingPostWithHttpInfo(pendingSignupRequest: PendingSignupRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = signupPendingApiAuthSignupPendingPostRequestConfig(pendingSignupRequest = pendingSignupRequest, authorization = authorization)

        return request<PendingSignupRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation signupPendingApiAuthSignupPendingPost
     *
     * @param pendingSignupRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun signupPendingApiAuthSignupPendingPostRequestConfig(pendingSignupRequest: PendingSignupRequest, authorization: kotlin.String?) : RequestConfig<PendingSignupRequest> {
        val localVariableBody = pendingSignupRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/signup/pending",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/auth/signup/pending
     * Signup Pending
     * Store temporary signup data after Identity Platform user creation.  Requires a valid Identity ID token.
     * @param pendingSignupRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun signupPendingApiAuthSignupPendingPost_0(pendingSignupRequest: PendingSignupRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = signupPendingApiAuthSignupPendingPost_0WithHttpInfo(pendingSignupRequest = pendingSignupRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/auth/signup/pending
     * Signup Pending
     * Store temporary signup data after Identity Platform user creation.  Requires a valid Identity ID token.
     * @param pendingSignupRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun signupPendingApiAuthSignupPendingPost_0WithHttpInfo(pendingSignupRequest: PendingSignupRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = signupPendingApiAuthSignupPendingPost_0RequestConfig(pendingSignupRequest = pendingSignupRequest, authorization = authorization)

        return request<PendingSignupRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation signupPendingApiAuthSignupPendingPost_0
     *
     * @param pendingSignupRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun signupPendingApiAuthSignupPendingPost_0RequestConfig(pendingSignupRequest: PendingSignupRequest, authorization: kotlin.String?) : RequestConfig<PendingSignupRequest> {
        val localVariableBody = pendingSignupRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/auth/signup/pending",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PATCH /api/auth/profile
     * Update Profile
     * Update user profile information including name and username.
     * @param profileUpdateRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateProfileApiAuthProfilePatch(profileUpdateRequest: ProfileUpdateRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = updateProfileApiAuthProfilePatchWithHttpInfo(profileUpdateRequest = profileUpdateRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PATCH /api/auth/profile
     * Update Profile
     * Update user profile information including name and username.
     * @param profileUpdateRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateProfileApiAuthProfilePatchWithHttpInfo(profileUpdateRequest: ProfileUpdateRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = updateProfileApiAuthProfilePatchRequestConfig(profileUpdateRequest = profileUpdateRequest, authorization = authorization)

        return request<ProfileUpdateRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateProfileApiAuthProfilePatch
     *
     * @param profileUpdateRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun updateProfileApiAuthProfilePatchRequestConfig(profileUpdateRequest: ProfileUpdateRequest, authorization: kotlin.String?) : RequestConfig<ProfileUpdateRequest> {
        val localVariableBody = profileUpdateRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/auth/profile",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PATCH /api/auth/profile
     * Update Profile
     * Update user profile information including name and username.
     * @param profileUpdateRequest 
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateProfileApiAuthProfilePatch_0(profileUpdateRequest: ProfileUpdateRequest, authorization: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = updateProfileApiAuthProfilePatch_0WithHttpInfo(profileUpdateRequest = profileUpdateRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PATCH /api/auth/profile
     * Update Profile
     * Update user profile information including name and username.
     * @param profileUpdateRequest 
     * @param authorization  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateProfileApiAuthProfilePatch_0WithHttpInfo(profileUpdateRequest: ProfileUpdateRequest, authorization: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = updateProfileApiAuthProfilePatch_0RequestConfig(profileUpdateRequest = profileUpdateRequest, authorization = authorization)

        return request<ProfileUpdateRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateProfileApiAuthProfilePatch_0
     *
     * @param profileUpdateRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun updateProfileApiAuthProfilePatch_0RequestConfig(profileUpdateRequest: ProfileUpdateRequest, authorization: kotlin.String?) : RequestConfig<ProfileUpdateRequest> {
        val localVariableBody = profileUpdateRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/auth/profile",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
