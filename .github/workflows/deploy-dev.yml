name: CD - Deploy to Dev (jualuma-dev)
# Security posture: Dev must remain authenticated-only (no public invoker).

on:
  push:
    branches: [Dev]

env:
  PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  REGION: us-central1

jobs:
  guard:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check for env_vars clobber
        run: python3 scripts/guard_env_vars.py ".github/workflows/deploy-dev.yml" --output github

  deploy:
    needs: [guard]
    runs-on: ubuntu-latest
    environment: development
    permissions:
      contents: "read"
      id-token: "write"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Google Auth
        uses: "google-github-actions/auth@v2"
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_WIF_SERVICE_ACCOUNT }}

      - name: "Set up Cloud SDK"
        uses: "google-github-actions/setup-gcloud@v2"

      - name: Install Cloud SDK beta component
        run: gcloud components install beta --quiet

      - name: "Authorize Docker"
        run: gcloud auth configure-docker us-central1-docker.pkg.dev

      - name: Load browser API key from Secret Manager
        run: |
          echo "VITE_GCP_API_KEY=$(gcloud secrets versions access latest --secret=VITE_GCP_API_KEY --project=${{ env.PROJECT_ID }})" >> "$GITHUB_ENV"

      - name: Validate Plaid production credentials
        run: |
          set -euo pipefail
          export PLAID_CLIENT_ID="$(gcloud secrets versions access latest --secret=PLAID_CLIENT_ID --project=${PROJECT_ID})"
          export PLAID_SECRET="$(gcloud secrets versions access latest --secret=PLAID_SECRET --project=${PROJECT_ID})"
          export PLAID_ENV="production"
          export PLAID_REDIRECT_URI="https://frontend-app-77ybfmw7cq-uc.a.run.app/connect-accounts"
          ./scripts/check_plaid_credentials.sh

      # 1. Backend
      - name: Build and Push Backend
        run: |
          docker build -t us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/backend:latest -f backend/Dockerfile .
          docker push us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/backend:latest
      # NOTE: Runtime env vars/secrets are controlled via the repository + CI promotion flow.
      # Secrets (via secretKeyRef): DATABASE_URL, STRIPE_SECRET_KEY,
      #   PLAID_CLIENT_ID, PLAID_SECRET, TATUM_API_KEY, TATUM_BASE_URL,
      #   LOCAL_ENCRYPTION_KEY, JOB_RUNNER_SECRET,
      #   GMAIL_SA_KEY (-> GOOGLE_APPLICATION_CREDENTIALS)
      # Plain env vars (managed through deployment-controlled service config): APP_ENV, PLAID_ENV,
      #   GCP_PROJECT_ID, STRIPE_PUBLISHABLE_KEY, FRONTEND_URL,
      #   BACKEND_CORS_ORIGINS, GMAIL_IMPERSONATE_USER,
      #   TATUM_TIMEOUT_SECONDS, TATUM_RETRY_MAX_ATTEMPTS, TATUM_RETRY_BASE_BACKOFF_MS
      # Do NOT redeclare here without controlled config updates -- doing so overwrites secretKeyRef bindings
      # and drops any vars not listed. See scripts/guard_env_vars.py.
      - name: Deploy Backend
        id: deploy_backend
        uses: "google-github-actions/deploy-cloudrun@v2"
        with:
          service: "jualuma-backend"
          image: "us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/backend:latest"
          region: ${{ env.REGION }}
          flags: >-
            --no-allow-unauthenticated
            --invoker-iam-check
            --ingress=all

      - name: Enforce Plaid production mode on backend runtime
        run: |
          gcloud run services update jualuma-backend \
            --project="${PROJECT_ID}" \
            --region="${REGION}" \
            --update-env-vars=PLAID_ENV=production,PLAID_REDIRECT_URI=https://frontend-app-77ybfmw7cq-uc.a.run.app/connect-accounts \
            --quiet

      # 2. Frontend App (VITE_GCP_API_KEY required for Identity Platform sign-up/sign-in)
      - name: Build and Push Frontend App
        run: |
          API_BASE_URL="${{ steps.deploy_backend.outputs.url }}"
          if [[ -z "${API_BASE_URL}" ]]; then
            echo "Missing backend deployment URL output"
            exit 1
          fi

          docker build \
            --build-arg VITE_GCP_API_KEY="${{ env.VITE_GCP_API_KEY }}" \
            --build-arg VITE_API_BASE_URL="${API_BASE_URL}" \
            -t us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/frontend-app:latest \
            -f frontend-app/Dockerfile .
          docker push us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/frontend-app:latest
      - name: Deploy Frontend App
        id: deploy_frontend
        uses: "google-github-actions/deploy-cloudrun@v2"
        with:
          service: "frontend-app"
          image: "us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/frontend-app:latest"
          region: ${{ env.REGION }}
          env_vars: |-
            API_UPSTREAM=${{ steps.deploy_backend.outputs.url }}
          flags: >-
            --no-allow-unauthenticated
            --invoker-iam-check
            --ingress=all

      # 3. Marketing
      - name: Build and Push Marketing
        env:
          NEXT_PUBLIC_APP_URL_RUNTIME: ${{ steps.deploy_frontend.outputs.url }}
          NEXT_PUBLIC_API_URL_RUNTIME: ${{ steps.deploy_backend.outputs.url }}
        run: |
          APP_URL="${NEXT_PUBLIC_APP_URL_RUNTIME}"
          API_URL="${NEXT_PUBLIC_API_URL_RUNTIME}"

          if [[ -z "${APP_URL}" ]]; then
            echo "Missing frontend deployment URL output"
            exit 1
          fi
          if [[ -z "${API_URL}" ]]; then
            echo "Missing backend deployment URL output"
            exit 1
          fi

          docker build \
            --build-arg NEXT_PUBLIC_APP_URL="${APP_URL}" \
            --build-arg NEXT_PUBLIC_API_URL="${API_URL}" \
            -t us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/marketing-site:latest \
            -f frontend-marketing/Dockerfile .
          docker push us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/marketing-site:latest
      - name: Deploy Marketing
        id: deploy_marketing
        uses: "google-github-actions/deploy-cloudrun@v2"
        with:
          service: "marketing-site"
          image: "us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/marketing-site:latest"
          region: ${{ env.REGION }}
          flags: >-
            --no-allow-unauthenticated
            --invoker-iam-check
            --ingress=all

      # 4. Support
      - name: Build and Push Support
        run: |
          API_BASE_URL="${{ steps.deploy_backend.outputs.url }}"
          if [[ -z "${API_BASE_URL}" ]]; then
            echo "Missing backend deployment URL output"
            exit 1
          fi

          docker build \
            --build-arg VITE_GCP_API_KEY="${{ env.VITE_GCP_API_KEY }}" \
            --build-arg VITE_API_BASE_URL="${API_BASE_URL}" \
            -t us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/support-portal:latest \
            -f support-portal/Dockerfile .
          docker push us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/support-portal:latest
      - name: Deploy Support
        id: deploy_support
        uses: "google-github-actions/deploy-cloudrun@v2"
        with:
          service: "support-portal"
          image: "us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/jualuma-repo/support-portal:latest"
          region: ${{ env.REGION }}
          env_vars: |-
            API_UPSTREAM=${{ steps.deploy_backend.outputs.url }}
          flags: >-
            --no-allow-unauthenticated
            --invoker-iam-check
            --ingress=all

      - name: Align backend runtime URLs (Dev)
        run: |
          set -euo pipefail

          FRONTEND_URL="${{ steps.deploy_frontend.outputs.url }}"
          SUPPORT_URL="${{ steps.deploy_support.outputs.url }}"
          MARKETING_URL="${{ steps.deploy_marketing.outputs.url }}"

          if [[ -z "${FRONTEND_URL}" || -z "${SUPPORT_URL}" || -z "${MARKETING_URL}" ]]; then
            echo "Missing service URL output(s) needed to align backend runtime URLs"
            exit 1
          fi

          gcloud run services update jualuma-backend \
            --project="${PROJECT_ID}" \
            --region="${REGION}" \
            --update-env-vars="^|^PLAID_ENV=production|PLAID_REDIRECT_URI=${FRONTEND_URL}/connect-accounts|FRONTEND_URL=${FRONTEND_URL}|BACKEND_CORS_ORIGINS=${FRONTEND_URL},${SUPPORT_URL},${MARKETING_URL}|GMAIL_OTP_IMPERSONATE_USER=noreply@jualuma.com" \
            --update-secrets=AI_FREE_MODEL=AI_FREE_MODEL:latest,AI_PAID_FALLBACK_MODEL=AI_PAID_FALLBACK_MODEL:latest \
            --quiet

      - name: Enforce runtime access posture (Dev)
        run: |
          set -euo pipefail

          for service in frontend-app support-portal marketing-site jualuma-backend; do
            gcloud run services remove-iam-policy-binding "$service" \
              --project="${PROJECT_ID}" \
              --region="${REGION}" \
              --member="allUsers" \
              --role="roles/run.invoker" \
              --quiet || true
          done

          # Backend uses app-layer auth; keep /api/health public and disable IAP.
          gcloud run services update jualuma-backend \
            --project="${PROJECT_ID}" \
            --region="${REGION}" \
            --no-invoker-iam-check \
            --ingress=all \
            --quiet
          gcloud beta run services update jualuma-backend \
            --project="${PROJECT_ID}" \
            --region="${REGION}" \
            --no-iap \
            --quiet

          # Web shells stay protected by IAP with invoker IAM checks enabled.
          for service in frontend-app support-portal marketing-site; do
            gcloud run services update "$service" \
              --project="${PROJECT_ID}" \
              --region="${REGION}" \
              --invoker-iam-check \
              --ingress=all \
              --quiet
            gcloud beta run services update "$service" \
              --project="${PROJECT_ID}" \
              --region="${REGION}" \
              --iap \
              --quiet
          done

      - name: Verify authenticated access policy (Dev)
        run: |
          set -euo pipefail

          FRONTEND_URL="${{ steps.deploy_frontend.outputs.url }}"
          BACKEND_URL="${{ steps.deploy_backend.outputs.url }}"
          SUPPORT_URL="${{ steps.deploy_support.outputs.url }}"
          MARKETING_URL="${{ steps.deploy_marketing.outputs.url }}"

          check_requires_auth() {
            local url="$1"
            local method="${2:-GET}"
            local data="${3:-}"
            local headers_file body_file status
            headers_file="$(mktemp)"
            body_file="$(mktemp)"

            if [[ "$method" == "POST" ]]; then
              status="$(curl -sS -D "$headers_file" -o "$body_file" \
                -X POST "$url" \
                -H "Content-Type: application/json" \
                --data "$data" \
                -w "%{http_code}")"
            else
              status="$(curl -sS -D "$headers_file" -o "$body_file" "$url" -w "%{http_code}")"
            fi

            if grep -qi '^x-goog-iap-generated-response:' "$headers_file"; then
              echo "::error::IAP interception detected at $url"
              sed -n '1,30p' "$headers_file"
              exit 1
            fi

            if [[ "${status}" != "401" && "${status}" != "403" ]]; then
              echo "::error::Expected unauthenticated request to be blocked at $url (status=$status)"
              sed -n '1,30p' "$headers_file"
              sed -n '1,40p' "$body_file"
              exit 1
            fi
          }

          check_requires_iap() {
            local url="$1"
            local headers_file body_file status location
            headers_file="$(mktemp)"
            body_file="$(mktemp)"

            status="$(curl -sS -D "$headers_file" -o "$body_file" "$url" -w "%{http_code}")"
            location="$(awk 'BEGIN{IGNORECASE=1} /^location:/ {print $2}' "$headers_file" | tr -d '\r' | head -n1)"

            if grep -qi '^x-goog-iap-generated-response:' "$headers_file"; then
              return 0
            fi

            if [[ -n "${location}" && ( "${location}" == *"_gcp_iap"* || "${location}" == *"accounts.google.com"* ) ]]; then
              return 0
            fi

            echo "::error::Expected IAP interception at $url (status=$status)"
            sed -n '1,30p' "$headers_file"
            sed -n '1,40p' "$body_file"
            exit 1
          }

          check_health_public() {
            local url="$1"
            local headers_file body_file status
            headers_file="$(mktemp)"
            body_file="$(mktemp)"

            status="$(curl -sS -D "$headers_file" -o "$body_file" "$url" -w "%{http_code}")"
            if [[ "${status}" != "200" ]]; then
              echo "::error::Expected public health endpoint at $url (status=$status)"
              sed -n '1,30p' "$headers_file"
              sed -n '1,40p' "$body_file"
              exit 1
            fi

            if grep -qi '^x-goog-iap-generated-response:' "$headers_file"; then
              echo "::error::Unexpected IAP interception for health endpoint $url"
              sed -n '1,30p' "$headers_file"
              sed -n '1,40p' "$body_file"
              exit 1
            fi
          }

          check_requires_iap "${FRONTEND_URL}/"
          check_requires_iap "${SUPPORT_URL}/"
          check_requires_iap "${MARKETING_URL}/pricing"
          check_health_public "${BACKEND_URL}/api/health"

          check_requires_auth \
            "${BACKEND_URL}/api/auth/signup/pending" \
            "POST" \
            '{"agreements":[],"first_name":"probe","last_name":"probe"}'
